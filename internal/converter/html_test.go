package converter

import (
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestRenderMarkdownToHTML(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		markdown string
		contains []string
	}{
		{
			name:     "heading",
			markdown: "# Hello World",
			contains: []string{"<h1", "Hello World", "</h1>"},
		},
		{
			name:     "paragraph",
			markdown: "This is a paragraph.",
			contains: []string{"<p>", "This is a paragraph.", "</p>"},
		},
		{
			name:     "table",
			markdown: "| Col1 | Col2 |\n|------|------|\n| a | b |",
			contains: []string{"<table>", "<th>", "Col1", "Col2", "<td>", "a", "b"},
		},
		{
			name:     "link",
			markdown: "[opnDossier](https://example.com)",
			contains: []string{`<a href="https://example.com"`, "opnDossier"},
		},
		{
			name:     "bold and italic",
			markdown: "**bold** and *italic*",
			contains: []string{"<strong>bold</strong>", "<em>italic</em>"},
		},
		{
			name:     "code block",
			markdown: "```\nfoo := bar\n```",
			contains: []string{"<pre>", "<code>", "foo := bar"},
		},
		{
			name:     "unordered list",
			markdown: "- item 1\n- item 2",
			contains: []string{"<ul>", "<li>", "item 1", "item 2"},
		},
		{
			name:     "empty input",
			markdown: "",
			contains: []string{"<!DOCTYPE html>", "<body>", "</body>"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			result, err := renderMarkdownToHTML(tt.markdown)
			require.NoError(t, err)

			for _, expected := range tt.contains {
				assert.Contains(t, result, expected)
			}
		})
	}
}

func TestRenderMarkdownToHTML_HTMLStructure(t *testing.T) {
	t.Parallel()

	result, err := renderMarkdownToHTML("# Test")
	require.NoError(t, err)

	// Verify self-contained HTML document structure
	assert.Contains(t, result, "<!DOCTYPE html>")
	assert.Contains(t, result, "<html lang=\"en\">")
	assert.Contains(t, result, "<meta charset=\"UTF-8\">")
	assert.Contains(t, result, "<title>OPNsense Configuration Report</title>")
	assert.Contains(t, result, "<style>")
	assert.Contains(t, result, "</style>")
	assert.Contains(t, result, "<body>")
	assert.Contains(t, result, "</body>")
	assert.Contains(t, result, "</html>")
	assert.Contains(t, result, "Generated by opnDossier")
}

func TestRenderMarkdownToHTML_NoExternalResources(t *testing.T) {
	t.Parallel()

	result, err := renderMarkdownToHTML("# Test")
	require.NoError(t, err)

	// Verify no external stylesheets or scripts are loaded
	assert.NotContains(t, result, `<link rel="stylesheet"`)
	assert.NotContains(t, result, `<script`)
	assert.NotContains(t, result, `src="http`)
}

func TestRenderMarkdownToHTML_DarkModeSupport(t *testing.T) {
	t.Parallel()

	result, err := renderMarkdownToHTML("# Test")
	require.NoError(t, err)

	assert.Contains(t, result, "prefers-color-scheme: dark")
}

func TestRenderMarkdownToHTML_PrintFriendly(t *testing.T) {
	t.Parallel()

	result, err := renderMarkdownToHTML("# Test")
	require.NoError(t, err)

	assert.Contains(t, result, "@media print")
}

func TestRenderMarkdownToHTML_LargeDocument(t *testing.T) {
	t.Parallel()

	// Build a moderately large markdown document
	var sb strings.Builder
	sb.WriteString("# Configuration Report\n\n")
	for i := range 50 {
		sb.WriteString("## Section ")
		sb.WriteString(strings.Repeat("X", 3))
		sb.WriteString("\n\n")
		sb.WriteString("| Key | Value |\n|-----|-------|\n")
		for j := range 5 {
			_, _ = fmt.Fprintf(&sb, "| key_%d_%d | value_%d_%d |\n", i, j, i, j)
		}
		sb.WriteString("\n")
	}

	result, err := renderMarkdownToHTML(sb.String())
	require.NoError(t, err)
	assert.Contains(t, result, "<!DOCTYPE html>")
	assert.Contains(t, result, "Configuration Report")
	assert.Contains(t, result, "<table>")
}
